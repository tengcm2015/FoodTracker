# creating a custom view

You typically create a view in one of two ways: by programatically initializing the view, or by allowing the view to be loaded by the storyboard. There’s a corresponding initializer for each approach: `init(frame:)` for programatically initializing the view and `init?(coder:)` for loading the view from the storyboard. Recall that an initializer is a method that prepares an instance of a class for use, which involves setting an initial value for each property and performing any other setup.

You will need to implement both of these methods in your custom control. While designing the app, Interface Builder programatically instantiates the view when you add it to the canvas. At runtime, your app loads the view from the storyboard.

# Add Buttons to the View
```swift
private func setupButtons() {

    // Create the button
    let button = UIButton()
    button.backgroundColor = UIColor.red

    // Add constraints
    button.translatesAutoresizingMaskIntoConstraints = false
    button.heightAnchor.constraint(equalToConstant: 44.0).isActive = true
    button.widthAnchor.constraint(equalToConstant: 44.0).isActive = true

    // Add the button to the stack
    addArrangedSubview(button)
}
```

```swift
let button = UIButton()
button.backgroundColor = UIColor.red
```
Here, you are using one of the `UIButton` class’s convenience initializers. This initializer calls `init(frame:)` and passes in a zero-sized rectangle. Starting with a zero-sized button is fine, because you’re using Auto Layout. The stack view will automatically define the button’s position, and you will add constraints to define the button’s size.
You are using `red` so it’s easy to see where the view is. If you’d like, use one of the other predefined `UIColor` values instead, like `blue` or `green`.

```swift
button.translatesAutoresizingMaskIntoConstraints = false
button.heightAnchor.constraint(equalToConstant: 44.0).isActive = true
button.widthAnchor.constraint(equalToConstant: 44.0).isActive = true
```

The first line of code disables the button’s automatically generated constraints. When you programmatically instantiate a view, its `translatesAutoresizingMaskIntoConstraints` property defaults to `true`. This tells the layout engine to create constraints that define the view’s size and position based on the view’s `frame` and `autoresizingmask` properties. Typically, when you are using Auto Layout, you want to replace these autogenerated constraints with your own. To remove the autogenerated constraints, set the `translatesAutoresizingMaskIntoConstraints` property to `false`.

* NOTE

    This line is not strictly necessary. When you add a view to a stack view, the stack view automatically sets the view’s `translatesAutoresizingMaskIntoConstraints` property to `false`. However, when using Auto Layout, it’s a good habit to explicitly disable the autogenerated constraints whenever you programmatically create a view. That way you won’t accidentally forget to disable them when it actually matters.

The lines starting with `button.heightAnchor` and `button.widthAnchor` create the constraints that define the button’s height and width. Each line performs the following steps:
1. The button’s `heightAnchor` and `widthAnchor` properties give access to layout anchors. You use layout anchors to create constraints—in this case, constraints that define the view’s height and width, respectively.
1. The anchor’s `constraint(equalToConstant:)` method returns a constraint that defines a constant height or width for the view.
1. The constraint’s `isActive` property activates or deactivates the constraint. When you set this property to `true`, the system adds the constraint to the correct view, and activates it.

Together, these lines define the button as a fixed-size object in your layout (44 point x 44 point).

```swift
addArrangedSubview(button)
```
The `addArrangedSubview()` method adds the button you created to the list of views managed by the `RatingControl` stack view. This action adds the view as a subview of the `RatingControl`, and also instructs the `RatingControl` to create the constraints needed to manage the button’s position within the control.

## Add actions to button

```swift
private func setupButtons() {

    // Create the button
    ...
    // Add constraints
    ...

    // Setup the button action
    button.addTarget(self, action: #selector(RatingControl.ratingButtonTapped(button:)), for: .touchUpInside)

    // Add the button to the stack
    ...
}
```
In the previous lesson, you used the target-action pattern to link elements in your storyboard to action methods in your code. The `addTarget(_, action:, for:)` method does the same thing in code. You’re attaching the `ratingButtonTapped(_:)` action method to the `button` object, which will be triggered whenever the `.TouchDown` event occurs.
There’s a lot going on in this code. Here’s a breakdown:
* The target is `self`, which refers to the current instance of the enclosing class. In this case, it refers to the RatingControl object that is setting up the buttons.
* The `#selector` expression returns the `Selector` value for the provided method. A selector is an opaque value that identifies the method. Older APIs used selectors to dynamically invoke methods at runtime. While newer APIs have largely replaced selectors with blocks, many methods—like `performSelector(_:)` and `addTarget(_:action:forControlEvents:)`—still take selectors as arguments. In this example, the `#selector(RatingControl.ratingButtonTapped(_:))` expression returns the selector for your `ratingButtonTapped(_:)` action method. This lets the system call your action method when the button is tapped.
* The `UIControlEvents` option set defines a number of events that controls can respond to. Typically buttons respond to the `.touchUpInside` event. This occurs when the user touches the button, and then lifts their finger while the finger is still within the button’s bounds. This event has an advantage over `.touchDown`, because the user can cancel the event by dragging their finger outside the button before lifting it.
* Note that because you’re not using Interface Builder, you don’t need to define your action method with the `IBAction` attribute; you just define the action like any other method. You can use a method that takes no arguments, that takes a single sender argument, or that takes both a sender and an event argument.
    ```swift
func doSomething()
func doSomething(sender: UIButton)
func doSomething(sender: UIButton, forEvent event: UIEvent)
    ```

# Interface Builder

Define the control as `@IBDesignable` lets Interface Builder instantiate and draw a copy of your control directly in the canvas. Additionally, now that Interface Builder has a live copy of your control, its layout engine can properly position and size the control.

```swift
@IBDesignable class RatingControl: UIStackView {
}
```

## Inspectable properties

You can also specify properties that can then be set in the Attributes inspector. Add the `@IBInspectable` attribute to the desired properties. Interface Builder supports the inspection of basic types (and their corresponding optionals), including: Booleans, numbers, strings, as well as `CGRect`, `CGSize`, `CGPoint`, and `UIColor`.

## Property observer

To update the control, you need to reset the control’s buttons every time these attributes change. To do that, add a property observer to each property. A property observer observes and responds to changes in a property’s value. Property observers are called every time a property’s value is set, and can be used to perform work immediately before or after the value changes.

```swift
@IBInspectable var starSize: CGSize = CGSize(width: 44.0, height: 44.0) {
    didSet {
        setupButtons()
    }
}

@IBInspectable var starCount: Int = 5 {
    didSet {
        setupButtons()
    }
}
```

Here, you define property observers for the `starSize` and `starCount` properties. Specifically, the `didSet` property observer is called immediately after the property’s value is set. Your implementation then calls the setupButtons() method. This method adds new buttons using the updated size and count.

# Delete Buttons

```
private func setupButtons() {

    // clear any existing buttons
    for button in ratingButtons {
        removeArrangedSubview(button)
        button.removeFromSuperview()
    }
    ratingButtons.removeAll()

    ...
}
```

This code iterates over all of the rating control’s buttons. First, it removes the button from the list of views managed by the stack view. This tells the stack view that it should no longer calculate the button’s size and position—but the button is still a subview of the stack view. Next, the code removes the button from the stack view entirely. Finally, once all the buttons have been removed, it clears the `ratingButtons` array.

# Set images

```swift
let bundle = Bundle(for: type(of: self))
let filledStar = UIImage(named: "filledStar", in: bundle, compatibleWith: self.traitCollection)
let emptyStar = UIImage(named:"emptyStar", in: bundle, compatibleWith: self.traitCollection)
let highlightedStar = UIImage(named:"highlightedStar", in: bundle, compatibleWith: self.traitCollection)
```

These lines load the star images from the assets catalog. Note that the assets catalog is located in the app’s main bundle. This means that the app can load the images using the shorter `UIImage(named:)` method. However, because the control is `@IBDesignable`, the setup code also needs to run in Interface Builder. For the images to load properly in Interface Builder, you must explicitly specify the catalog’s bundle. This ensures that the system can find and load the image.

```swift
// Set the button images
button.setImage(emptyStar, for: .normal)
button.setImage(filledStar, for: .selected)
button.setImage(highlightedStar, for: .highlighted)
button.setImage(highlightedStar, for: [.highlighted, .selected])
```
Buttons have five different states: normal, highlighted, focused, selected, and disabled. By default, the button modifies its appearance based on its state, for example a disabled button appears grayed out. A button can be in more than one state at the same time, such as when a button is both disabled and highlighted.
Buttons always start in the normal state (not highlighted, selected, focused, or disabled). A button is highlighted whenever the user touches it. You can also programmatically set a button to be selected or disabled. The focused state is used by focus-based interfaces, like Apple TV.
In the code above, you are telling the button to use the empty star image for the normal state. This is the button’s default image. The system uses this image (possibly with an added effect) whenever a state or combination of states doesn’t have an image of their own.
Next, the code above sets the filled image for the selected state. If you programmatically set the button as selected, it will change from the empty star to the filled star.
Finally, you set the highlighted image for both the highlighted and the selected and highlighted states. When the user touches the button, whether or not it is selected, the system will show the highlighted button image.
